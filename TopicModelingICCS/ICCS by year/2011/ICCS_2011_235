Available online at www.sciencedirect.com

Procedia Computer Science 4 (2011) 36‚Äì45

International Conference on Computational Science, ICCS 2011

A VeriÔ¨Åed Bulk Synchronous Parallel ML Heat DiÔ¨Äusion Simulation
Julien Tessona , Fr¬¥ed¬¥eric Loulerguea
a LIFO,

Universit¬¥e d‚ÄôOrl¬¥eans, France

Abstract
Bulk Synchronous Parallel ML (BSML) is a structured parallel functional programming language. It extends
a functional programming language of the ML family with a polymorphic data structure and a very small set of
primitives. In this paper we describe a framework for reasoning about BSML programs using the Coq interactive
theorem prover and for extracting actual parallel programs from proofs. This framework is illustrated through a
simulation application based on heat equation.
Keywords: Bulk synchronous parallelism, functional programming, formal semantics, proof assistant

1. Introduction
Hardware with parallel computing capabilities is now everywhere, and the number of processing elements is
increasing making scalable programs necessary. However parallel programming is not yet as widespread as parallel
machines. Indeed in general, concurrent and parallel programs have a complex semantics and are yet diÔ¨Écult to design
and to reason about. In the same way unstructured sequential programs have progressively disappeared, unstructured
parallel programs using send/receive message passing [1] or low level concurrency primitives such as threads should
be avoided.
Several more structured approaches to parallel programming exist: data parallelism, algorithmic skeletons [2],
bulk synchronous parallelism [3] to cite a few. By restricting the possible forms of parallelism, these models make
parallel programs easier to write and easier to reason about. Their structured nature also helps the design of eÔ¨Écient
libraries and compilers to support them. Parallelism being everywhere, it is very important to be able to prove the
correctness of parallel programs used for example in critical applications, where an extra burden is acceptable as the
need for safety of execution override the race for pure computational performance.
Bulk Synchronous Parallel ML [4] is an extension of the Objective Caml language with bulk synchronous parallel
primitives. It is based on formal semantics and can be used for practical parallel programs development.
It is possible with the Coq proof assistant [5] to extract functional programs from proofs [6]. For example, the
CompCert compiler is extracted from a Coq development where each stage of the compiler is proved correct [7].
However all programs extracted from Coq developments are sequential programs.
Our contribution allows to reason about functional bulk synchronous parallel programs within Coq and to extract
actual BSML programs from the proofs. More precisely, in this paper we present:
Email addresses: Julien.Tesson@univ-orleans.fr (Julien Tesson), Frederic.Loulergue@univ-orleans.fr (Fr¬¥ed¬¥eric Loulergue)
URL: http://www.univ-orleans.fr/lifo/Members/Julien.Tesson (Julien Tesson), http://frederic.loulergue.eu (Fr¬¥ed¬¥eric
Loulergue)

1877‚Äì0509 ¬© 2011 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
Selection and/or peer-review under responsibility of Prof. Mitsuhisa Sato and Prof. Satoshi Matsuokaa
doi:10.1016/j.procs.2011.04.005

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

37

‚Ä¢ a consistent (with Coq‚Äôs logic) axiomatisation of BSML primitives,
‚Ä¢ proof of correctness of several parallel programs using this axiomatisation,
‚Ä¢ extraction of actual BSML programs from these proofs and execution on a parallel machine for performance
comparisons.
We begin by giving short introductions to parallel programming with BSML (section 2) and to the Coq interactive
theorem prover (section 3). We then present the formalisation in Coq of BSML parallel data structure and operations
(section 4) (together with the proof of correctness of a function of the BSML standard library in Coq) before applying
the framework to the proof of correctness and extraction of BSML code from this Coq development for a simulation
application (section 5). We perform some experiments on a parallel machine with this application (section 6). We end
by related work (section 7), conclusions and future work (section 8).
2. Bulk Synchronous Parallel ML
A bulk synchronous parallel or BSP [3] computer is a homogeneous distributed memory machine with a global
synchronisation unit. This architecture is an abstract one as any general purpose parallel architecture can be mapped
to this view. Most of the time, parts of the BSP abstraction are not hardware but emulated by software: for example
the global synchronisation unit in clusters.
A BSP program consists of a sequence of super-steps. Each super-step has three phases: the asynchronous computation phase where each processor performs some computations using only the data it owns, the communication
phase where processors exchange data, and the synchronisation phase where a barrier synchronises all the processors.
It is only after the synchronisation phase that the data exchanged during the communication phase are guaranteed to
be delivered and can be used by the next asynchronous computation phase.
One can write functional BSP programs with Bulk Synchronous Parallel ML or BSML [4, 8]. BSML is very
diÔ¨Äerent from the SPMD paradigm where a program is a parallel composition of sequential programs. BSML oÔ¨Äers a
global view of the program: it is similar to a sequential program but provides a parallel data structure and primitives
to work on it. In this respect it is close to data parallel languages. BSML‚Äôs parallel data structure is called parallel
vector. A parallel vector has a Ô¨Åxed size p, the number of processors of the parallel machine (this constant is called
bsp p in BSML). Each processor owns a value of the parallel vector. All the components of a parallel vector should
have the same type, and a component of a parallel vector should not be a parallel vector: nesting is forbidden (it can
be guaranteed by a type system [9], but in the current implementation ‚Äì that is not a full language but a library for the
Objective Caml [10] language ‚Äì the programmer is responsible for avoiding nesting). The type for a parallel vector
whose elements have type t is t par.
To create a parallel vector, the primitive mkpar should be used. Its signature is ( Œ± ‚Üí int)‚Üí Œ± par. For example
the following shows the evaluation of an expression in the BSML top-level (in which the user can interactively enter
expressions that are immediately evaluated):
# let this = Bsml.mkpar (fun i ‚Üí i);;
val this : int Bsml.par = <0, 1, 2, 3>

The Ô¨Årst line begins with the prompt # of the interactive loop, the second line is its answer: a new value called this
is created, a parallel vector of integers. As we have in this example a 4 processors machine, this vector contains 4
values. As Objective Caml is a higher-order language it is possible to create parallel vectors of functions:
# let vf = Bsml.mkpar (fun i ‚Üí if i mod 2 = 0 then ( + ) 1 else ( + ) (‚àí1) );;
fun>, <fun>, <fun>, <fun
val vf : (int ‚Üí int) Bsml.par =

For an inÔ¨Åx operator ‚äï, the notation ( ‚äï ) is its preÔ¨Åx version. Thus ( + ) 1 is the function that adds 1 to its argument.
The parallel vector vf contains this function on even processor and the function that subtracts one from its argument
on the odd processors.
A parallel vector of functions is not a function, so it is not applicable to a parallel vector of values. Therefore
we need a primitive to perform this kind of application. This is the role of the apply primitive whose signature is
( Œ± ‚Üí Œ≤ )par‚Üí Œ± par‚Üí Œ≤ par:

38

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

# let v1 = Bsml.apply vf this;;
val v1 : int Bsml.par = <1, 0, 3, 2>

The last primitive of BSML (we omit two other primitives including super [11] as they are not used in this paper)
is a primitive that requests a full super-step to be evaluated. put allows us to write explicit communications. Its
signature is (int‚Üí Œ± )par‚Üí (int‚Üí Œ± )par. At each processor i, the messages to be sent are encoded as a function fi . For
a destination processor j, the message sent from i to j is ( fi j). The received messages in the resulting parallel vector
are encoded in the same way: at processor j the vector contains a function g j , the value (g j i) is the value sent by
processor i to processor j. The values that are the Ô¨Årst constant case of a sum type are considered to have size 0 and
are actually not sent through the network (however the result of put is as if they were sent). For example, this is the
case for the empty list. The following example shifts the values of a vector to the right in a circular way:
# open Bsml;;
# let replicate x = mkpar(fun pid ‚Üí x);;
val replicate : Œ± ‚Üí Œ± Bsml.par = <fun>
# let parfun f v = apply(replicate f) v;;
val parfun : ( Œ± ‚Üí Œ≤ ) ‚Üí Œ± Bsml.par ‚Üí Œ≤ Bsml.par = <fun>
# let shift v =
let build messages pid lv dst = if dst=natmod (pid+1) bsp p then [lv] else [] in
let messages to send = apply (mkpar build messages) v in
parfun List.hd (apply (put messages to send)(mkpar(fun pid‚Üí natmod (pid‚àí1) bsp p)));;
val shift : Œ± Bsml.par ‚Üí Œ± Bsml.par = <fun>
# let = shift v1;;
‚àí : int Bsml.par = <2, 1, 0, 3>

In this example we use [] the empty list to represent empty messages. We Ô¨Årst build the parallel vector of functions
needed for a call to put. This message to send parallel vector is built using the v parallel vector that contains the values
we want to send. If the destination processor (dst) is equal to the source processor (pid) plus one, then a singleton list
with the local value of v (i.e. the value of v at the current pid processor) is sent. The result of (put messages to send)
is also a parallel vector of functions. For a processor pid this function applied to the processor identiÔ¨Åer of its left
neighbour (whose identiÔ¨Åer is given by the expression natmod (pid‚àí1) bsp p, that evaluates to bsp p‚àí1 if pid equals
0), returns a singleton list containing the value of parallel vector v at processor pid‚Äôs left neighbour.
The BSML standard library contains a module Stdlib.Comm that oÔ¨Äers many communication related functions such
as shift. In practice most of the time the programmer uses these functions instead of using put directly. Nevertheless
this primitive exists and makes possible to write any BSP communication pattern.
3. A Short Introduction to the Coq Proof Assistant
The Coq proof assistant [13] is based on the calculus of inductive constructions. This calculus is a higher-order
typed Œª-calculus. Theorems are types and their proofs are terms of the calculus. The Coq system helps users to build
the proof terms and oÔ¨Äers a language of tactics to do so. We illustrate quickly all these notions on a short example
(Ô¨Ågure 1(a)).
In this example, we deÔ¨Åne a new inductive type, the type of natural numbers in the Peano style. nat has type Set
which means it belongs to the computational realm of the Coq language. We also deÔ¨Åne the plus recursive function on
naturals. In this recursive deÔ¨Ånition we specify the decreasing argument (here n1) as all functions must be terminating
in Coq. For both deÔ¨Ånitions, we have to give the type of the entity we want to deÔ¨Åne as well as a term of this type.
We then deÔ¨Åne a lemma named plus n O which states that ‚àÄn, plus n O = n. If we check (using the Check command
of Coq) the type of this expression, we would obtain Prop meaning that this expression belongs to the logical realm.
To deÔ¨Åne plus n O we should provide a term of this type, that is a proof of this lemma. We could write directly such a
term, but it is usually complicated and Coq provides a language of tactics to help the user to build a proof term.
If we give to Coq‚Äôs top-level the line of Ô¨Ågure 1(a) beginning with Lemma, we would enter the interactive proof
mode that indicates us that we should prove the following goal:
============================
forall n : nat, plus n O = n

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

Inductive nat:Set := O : nat | S : nat ‚Üínat.
Fixpoint plus (n1 n2 : nat) {struct n1} : nat :=
match n1 with
| O ‚áín2
| S n ‚áíS(plus n n2)
end.
Lemma plus n O : ‚àÄn, plus n O = n.
Proof. induction n.
(‚àó case n=0 ‚àó) simpl. reÔ¨Çexivity.
(‚àó case n>0 ‚àó) simpl. rewrite IHn. reÔ¨Çexivity.
Qed.

39

Inductive list (A:Type) : Type :=
| nil: list A
| cons: A ‚Üílist A ‚Üílist A.
Set Implicit Arguments.
Fixpoint length (A:Type) (l:list A) : nat :=
match l with
| nil ‚áíO
| cons head tail ‚áíS(length tail)
end.

(a)

(b)
Figure 1: Coq Short Examples

We prove this goal by induction on n using the tactic induction n. The system indicates now two goals to prove:
============================
plus O O = O
subgoal 2 is:
plus (S n) O = S n

The Ô¨Årst one is proved using the deÔ¨Ånition of plus using the tactic simpl which yields the goal 0 = 0 and this case is
ended by the application of the tactic reÔ¨Çexivity. The second one is the inductive case:
n : nat
IHn : plus n O = n
============================
plus (S n) O = S n

After simpliÔ¨Åcation, we obtain the goal S(plus n O) = S n. We solve it Ô¨Årst by rewriting plus n O to n using the IHn
hypothesis from the context and then we conclude by reÔ¨Çexivity.
Note that ‚àÄn, plus 0 n = n is immediate to prove because plus 0 n can be evaluated to n. Therefore to prove such a
goal, intros; reÔ¨Çexivity would be suÔ¨Écient (intros move all premisses from goal to the context).
The diÔ¨Äerence between Coq and functional programming languages such as ML or Haskell when dealing with
polymorphic types and functions is that type variables are manipulated explicitly. For example the type of lists and
the function that computes the length of a list could be deÔ¨Åned in Coq as shown in Ô¨Ågure 1(b). Note that even if length
has two arguments, the type of the list elements and the list itself, it is applied only to a list in the recursive call. Indeed
the command Set Implicit Arguments makes Coq infer implicit arguments, i.e. arguments that could be deduced from
the latter arguments. In the case of length the type of the elements are given when a concrete list with some elements
is given. With this feature the application of polymorphic functions in Coq is similar to parametric polymorphism in
ML or Haskell.
Mixing logical and computational parts is possible in Coq. For example a function of type A‚ÜíB with a precondition P and a postcondition Q corresponds to a constructive proof of type: ‚àÄx:A, (P x) ‚Üíexists y:B ‚Üí(Q x y). This could
be expressed in Coq using the inductive type sig: Inductive sig (A:Set) (Q:A‚ÜíProp) : Set := | exist: ‚àÄ(x:A), (Q x) ‚Üí(sig A Q)
It could also be written, using syntactic sugar, as {x:A|(P x)}.
This feature is used in the following deÔ¨Ånition of the function pred:
DeÔ¨Ånition pred : ‚àÄn:nat, n<>O‚Üí{q:nat|(S q)=n}.
Proof.
intros; destruct n. (‚àó case n=0 ‚àó) elim H. reÔ¨Çexivity. (‚àó case n>0 ‚àó) exists n. reÔ¨Çexivity.
DeÔ¨Åned.

The speciÔ¨Åcation of this function is: ‚àÄn:nat, n<>O‚Üí{q:nat|(S q)=n} and we build it using tactics. We reason by case on
n (tactic destruct). The Ô¨Årst case is easily solved because we have the hypothesis O<>O, the second one is trivial.

40

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

The command Extraction pred would extract the computational part of the deÔ¨Ånition of pred. We could obtain a
certiÔ¨Åed Objective Caml implementation of the predecessor function of type nat ‚Üínat:
let pred = function | O ‚Üí assert false (‚àó absurd case ‚àó) | S n0 ‚Üí n0

4. Shallow Embedding of BSML in Coq
A module type in Coq is a set of deÔ¨Ånitions or parameters and axioms, the latter being types without associated
proof terms. It is possible to build functors, i.e. modules that take other modules as arguments. In the Coq developments of our framework, all the modules related to parallelism are functors that take as argument a module which
provides a realization of the semantics of BSML. These semantics are modelled in a module type called PRIMITIVES.
The module type PRIMITIVES contains: the deÔ¨Ånition processor of processor names, and associated axioms; the
opaque type par of parallel vectors; the axioms which deÔ¨Åne the semantics of the parallel primitives of BSML (here
limited to the three primitives described in the previous section).
A natural bsp p, the total number of processors, is assumed to be deÔ¨Åned. It is assumed this natural is strictly
positive: Axiom bsp pNotZero: 0 < bsp p.
The type processor is deÔ¨Åned as: DeÔ¨Ånition processor := { pid: nat | pid < bsp p }.
The type of parallel vectors is an opaque type Parameter par: Type‚ÜíType. It is a polymorphic type thus it has as
argument the type of the values contained in the vectors. To access the members of a parallel vector, i.e. the local
values, a function get having the following speciÔ¨Åcation is assumed to be deÔ¨Åned:
Parameter get : ‚àÄA: Set, par A ‚Üíprocessor ‚ÜíA.

The semantics of the parallel primitives of BSML are then speciÔ¨Åed using the get function. It is a quite straightforward translation of the semi-formal semantics presented in Ô¨Ågure 2(b) (where v0 , . . . , v p‚àí1 is the notation for a
parallel vector and Œªx.e is the usual Œª-calculus notation for a function with e as a body and taking an argument x). In
Ô¨Ågure 2(a) instead of giving the result parallel vector as a whole, the Coq modelling describes the formal semantics of
the results of the primitives by giving the values of theirs components.
A term t of type {x:A | P x} is a value of type A and a proof that this value verify the property P. It is possible to get
these two parts using the functions proj1 sig and proj2 sig. Therefore what corresponds to the BSML mkpar function,
i.e. with only a computational content is:
DeÔ¨Ånition mkparBSML (A:Set) (f: processor ‚ÜíA) := proj1 sig(mkpar f).

the type of mkparBSML is ‚àÄA : Set, (processor ‚ÜíA) ‚Üípar A. And the following lemma holds for this function:
Lemma lmkpar: ‚àÄ(A:Set)(f:processor ‚ÜíA), ‚àÄ(i:processor), get (mkparBSML f) i = f i.
Proof. intros A f; apply(proj2 sig (mkpar f)). Qed.

The Program feature [14] of Coq allows us to use mkparas if it were the mkparBSML function. The lemma can be
rewritten:
Program Lemma lmkpar: ‚àÄ(A:Set)(f:processor ‚ÜíA), ‚àÄ(i:processor), get (mkpar f) i = f i.
Proof. intros A f; apply(proj2 sig (mkpar f)). Qed.

In this particular case we only need the computational part of mkpar, thus the Program feature simply removes it.
Sometimes we provide only the x part of a value t of type {x:A| P x}, and then the Program feature generates a proof
obligation to allow the use of x instead of t. As a matter of fact, using the tactics language to build the proof term
associated to lmkpar is not the simplest way. It is easier to give it directly:
Program DeÔ¨Ånition lmkpar (A:Set)(f:processor ‚ÜíA) := proj2 sig(mkpar f).

We provide these lemmas for all BSML primitives, and some additional deÔ¨Ånitions and results about processors, in
a functor BsmlProperties.Make. This module adds the lemmas to a hint base to be used by automated tactics of Coq,
making proof of BSML programs more convenient.

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

Parameter mkpar : ‚àÄ(A:Set) (f: processor ‚ÜíA),
{ vr: par A | ‚àÄi: processor, get vr i = f i }.
Parameter apply : ‚àÄ(A B: Set) (vf: par (A ‚ÜíB)) (vx: par A),
{ vr: par B | ‚àÄi: processor, get vr i = (get vf i) (get vx i) }.
Parameter put : ‚àÄ(A:Set) (vf: par (processor ‚ÜíA)),
{ vr: par (processor ‚ÜíA) | ‚àÄ(i j: processor), get vr i j = get vf j i }.

41

mkpar f =
apply
put

f 0 , . . . , f (p ‚àí 1)
f0 , . . . , f p‚àí1
x0 , . . . , x p‚àí1 =
f0 x0 , . . . , f p‚àí1 x p‚àí1
f0 , . . . , f p‚àí1 =
Œªi.( fi 0) , . . . , Œªi.( fi (p ‚àí 1))
(b)

(a)
Figure 2: Bulk Synchronous Parallel ML Primitives

Thus from the axioms presented above we obtain three functions that verify the speciÔ¨Åcations. These functions
and their properties are used to deÔ¨Åne and prove the correctness of BSML programs.
As a small example, we show how to deÔ¨Åne a certiÔ¨Åed version of the parfun function also deÔ¨Åned directly in BSML
in section 2:
Program DeÔ¨Ånition parfun(A B: Type)(f:A‚ÜíB)(v:par A) :
{ vr: par B | ‚àÄ(i:processor), get vr i = f (get v i) }:=
apply (replicate f) v.
Next Obligation.
autorewrite with bsml; reÔ¨Çexivity.
DeÔ¨Åned.

The second line is the speciÔ¨Åcation of this function, the third one is the deÔ¨Ånition in BSML style (computational part
only) and is identical to the deÔ¨Ånition of section 2. The Program feature generates a proof obligation (in this case that
the expression apply (replicate f) v meets the speciÔ¨Åcation). Using the hint base bsml, the proof is automatic.
5. An Application: Heat Equation
The diÔ¨Äusion of heat in a material (of length 1), in one dimension, is described by the equation:
Œ¥u
Œ¥2 u
‚àíŒ≥ 2 =0
Œ¥t
Œ¥ x
where x and t are reals. We assume boundary conditions u(0, t) = l and u(1, t) = r for some constants l and r. To
approximate function u it is possible to discretise this equation with the Ô¨Ånite diÔ¨Äerences method. For a time step dt
and a space step dx, the following equation is obtained:
u(x, t + dt) = Œ≥ √ó

dt
√ó u(x + dx, t) + u(x ‚àí dx, t) ‚àí 2 √ó u(x, t) + u(x, t)
dx2

(1)

To build a simulation program of heat diÔ¨Äusion, this equation is further approximated by considering Ô¨Çoating point
numbers instead of real numbers. The speciÔ¨Åcation of our program will be thus (1).
1
‚àí 1 values of u in
The Ô¨Årst step of our program in Coq is to write this speciÔ¨Åcation. We store the non-boundary dx
a list. Equation (1) describes the values of the list obtained from u after one simulation step. Moreover we should not
forget the boundary conditions. For x = dx (and similarly for x = 1 ‚àí dx), the equation is in fact:
u(x , t + dt) = Œ≥ √ó

dt
√ó u(x + dx, t) + l ‚àí 2 √ó u(x , t) + u(x , t)
dx2

For modelling this speciÔ¨Åcation we assume to have a type number with binary operations +, ‚àí, ‚àó and / in the number scope
scope. It is unnecessary to assume anything about their semantics. We just deÔ¨Åne the heatEqFormula as the right hand
side of equation (1):
Open Scope number scope.
DeÔ¨Ånition heatEqFormula (dt dx gamma uI uIMinusOne uIPlusOne : number) : number :=
gamma ‚àó dt / (dx ‚àó dx) ‚àó ( uIPlusOne + uIMinusOne ‚àí uI ‚àí uI) + uI.
Close Scope number scope.

42

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

The speciÔ¨Åcation of one step of our simulation application is then:
DeÔ¨Ånition stepSpeciÔ¨Åcation (step: number ‚Üínumber ‚Üínumber ‚Üínumber ‚Üínumber ‚Üílist number ‚Üílist number): Prop :=
‚àÄ(u : list number)(Hu: u<>[])(left right dt dx gamma: number) (i : nat)(Hi:i<length u)(default : number),
nth i (step left right dt dx gamma u) default =
heatEqFormula dt dx gamma (nth i u default) (if i==0 then left else nth (i‚àí1) u default) (nth (i+1) u right).

If u were an array we would write u[i] for its ith element. Here we write nth i u with an additional default argument
returned as result of the call to nth in case i is greater or equal to the length of the list. To manage boundary conditions,
for the left boundary we use a conditional, for the right boundary, using the default argument of nth is suÔ¨Écient.
A sequential program that veriÔ¨Åes this speciÔ¨Åcation follows:
Fixpoint heatSeq (left right dt dx gamma : number)(u : list number) : list number := match u with
| [] ‚áí[]
| uI :: u‚Äô ‚áímatch u‚Äô with
| [] ‚áí[ heatEqFormula dt dx gamma uI left right ]
| uIPlusOne:: ‚áí(heatEqFormula dt dx gamma uI left uIPlusOne)::(heatSeq uI right dt dx gamma u‚Äô)
end
end.

The proof1 that it indeed meets speciÔ¨Åcation stepSpeciÔ¨Åcation is done by induction and relies on the following lemma
where last and hd respectively returns the last and Ô¨Årst element of a list with a default value in case the list is empty,
and ++ is list concatenation:
Lemma heatSeqApp: ‚àÄ(left right dt dx gamma : number)(u1 u2: list number),
heatSeq left right dt dx gamma (u1 ++ u2) =
(heatSeq left (hd right u2) dt dx gamma u1) ++ (heatSeq (last u1 left) right dt dx gamma u2).

A parallel version follows (the u argument is implicit as it is also given by the Hu argument):
Program DeÔ¨Ånition heatPar (left right dt dx gamma:number)(u:par(list number))(Hu:‚àÄ i,get u i<>nil) : par(list number) :=
let bounds := getBounds left right Hu in apply(parfun2(fun l r‚áíheatSeq l r dt dx gamma)(fst bounds)(snd bounds)) u.

At a given processor, the getBounds function sends the Ô¨Årst (resp. last) element of its list to its left (resp. right)
neighbour. On the Ô¨Årst (resp. last) processor where nothing is sent from its left (resp. right) neighbour, the boundary
values are used instead. The Coq speciÔ¨Åcation of this function is given below (sHead (resp. sLast) returns the Ô¨Årst
(resp. last) element of a non-empty list), and the BSML code of the direct implementation in Ô¨Ågure 3 (the Coq version
uses an auxiliary function and the whole description would make the paper larger than the page limit: we refer to the
material available on the web):
Program DeÔ¨Ånition getBounds (A:Type)(left right : A)(v: par(list A))(H: ‚àÄi, get v i <> nil) :
{ vr : par A | ‚àÄ(i:processor), get vr i = if ( i == Ô¨ÅrstProcessor ) then left else sLast (get v (i‚àí1)) } ‚àó
{ vr : par A | ‚àÄ(i:processor), get vr i = if ( i == lastProcessor) then right else sHead (get v (min (i+1) lastProcessor)) } := ...

The theorem about the equivalence of the sequential and parallel versions (and hence the correctness of the parallel
version since the sequential version is correct with respect to stepSpeciÔ¨Åcation) of one step of simulation is stated as
follows, where listOfPar transforms a parallel vector of lists into a list:
Theorem heatParSeqEq: ‚àÄ(left right dt dx gamma:number)(u:par(list number))(Hu:‚àÄ i, get u i<>nil),
heatSeq left right dt dx gamma (listOfPar u) = listOfPar(heatPar left right dt dx gamma Hu).

This theorem is proved with two intermediate lemmas. The Ô¨Årst states that the list held at processor i after a parallel
step of simulation is the same as the list obtained by applying a step of sequential simulation of the list initially held
by processor i if the boundary conditions are the elements returned at processor i by the getBounds function:
Program Lemma heatParSeqEqAtI: ‚àÄ(left right dt dx gamma:number)(u:par(list number))(Hu:‚àÄ i, get u i<>nil)(i:processor),
(get (heatPar left right dt dx gamma Hu) i) = heatSeq (leftBoundAtI left Hu i) (rightBoundAtI right Hu i) dt dx gamma (get u i).

1 The

whole development including all the proofs is available at http://traclifo.univ-orleans.fr/BSML

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

43

(‚àó val getBounds: (‚Äôa‚Üí‚Äôb)‚Üí(‚Äôa‚Üí‚Äôb)‚Üí‚Äôb‚Üí‚Äôb‚Üí‚Äôa Bsml.par‚Üí‚Äôb Bsml.par ‚àó ‚Äôb Bsml.par ‚àó)
let getBounds Ô¨Årst last l bound r bound u =
let msg = put(Bsml.apply(Bsml.mkpar(fun pid lu dst ‚Üí
if (dst = (pid + 1)) && (pid <> (bsp p ‚àí 1)) then [ last lu ]
else if (dst = (pid ‚àí 1)) && (pid <> 0) then [ Ô¨Årst lu ] else [])) u ) in
(Bsml.apply(Bsml.mkpar(fun pid lmsg‚Üíif pid=0 then l bound else List.hd (lmsg (pid‚àí1)))) msg ,
Bsml.apply(Bsml.mkpar(fun pid lmsg‚Üíif pid=bsp p‚àí1 then r bound else List.hd (lmsg (pid+1)))) msg )
Figure 3: The BSML getBounds function

where leftBoundAtI is deÔ¨Åned as (and rightBoundAtI is deÔ¨Åned in a similar way):
Program DeÔ¨Ånition leftBoundAtI (left:number)(u:par(list number))(Hu:‚àÄ i,get u i<>nil)(i:processor): number :=
if ( (‚Äòi) == (‚ÄòÔ¨ÅrstProcessor) ) then left else sLast (get u (i‚àí1)).

The proof of this lemma distinguishes three cases on i: i is the Ô¨Årst processor, i is the last processor, i is another
processor.
Then the results obtained with heatParSeqEqAtI for all the possible values of i, should be combined. However to be
able to reason by induction, it is necessary to state and prove the following lemma instead of trying to prove directly
the theorem:
Program Lemma heatParSeqEqUpToI: ‚àÄ(i:processor)(left right dt dx gamma:number)(u:par(list number))(Hu:‚àÄ i,get u i<>nil),
heatSeq left (rightBoundAtI right Hu i) dt dx gamma (Ô¨Çatten (map (get u) (processorsUpTo i))) =
Ô¨Çatten(map(get(heatEquationPar left right dt dx gamma Hu))(processorsUpTo i)).

where Ô¨Çatten Ô¨Çattens a list of lists into a list and processorsUpTo i is the list of processors from the Ô¨Årst processor up to
i. This lemma is proved by induction on i (more precisely on proj1 sig i). The theorem can then be proved by applying
the previous lemma to the last processor.
6. Experiments
In the shallow embedding of BSML, processors are represented by Peano naturals together with the proof that they
are smaller than the number of available processors. After extraction in OCaml, the proof is removed and it remains
a Peano natural (type nat), whereas, in the OCaml implementation of BSML, native integer (type int) are used.
Therefore we implement a module providing BSML primitives with Peano naturals as processors index (called
BSMLnat) as requested by the functors extracted from our Coq development. This module has the OCaml module
type corresponding to the extraction of the BsmlSpec.PRIMITIVES Coq module type. To this end we implemented
conversions between Peano naturals and native integers. To avoid computing several times the same conversion from
a Peano natural to a native integer, computed Peano naturals are cached with their corresponding native integers.
The extracted heat equation implementation is encapsulated in a functor taking a module Number as argument
that provides a number type and its operation. For the benchmark, we apply this functor to a module containing Ô¨Çoat
type and its operations. This genericity introduces one level of indirection for each operation on Ô¨Çoats. Furthermore,
it prevents the compiler to use unboxed Ô¨Çoats and thus use much more memory. Therefore we also benchmark a
manually defunctorized version of our code.
We benchmark the extracted version against an OCaml hand-coded unproved version of the heat equation computation and the manually defunctorized version of the extracted one; all three implementations are used to compute the
solution of the equation over lists of increasing size. The computation times given are for 200 iterations of simulation
with a (full major) garbage collection at the end of each iteration. The examples have been launched several times on
the LIFO‚Äôs PC cluster called Mirev. The experiments used up to 8 nodes, with 2 quad-core processors per node. All
nodes are connected with a gigabit ethernet network. We use BSML 0.5 compiled with openMPI 1.4.2.
In both Ô¨Ågures 4(a) and 4(b) we can see that there is almost no diÔ¨Äerence between defunctorized and directly
implemented version. There is a growing overhead for the extracted, non-defunctorized version timing. It is due
to the garbage collector, which is triggered more often during the computation in this version, due to the memory
consumption overhead.

44

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

	







 





































(a)
















 	


	


	


	


	




(b)

Figure 4: Execution Time of Direct and Extracted Implementations with 1 and 16 Processors

7. Related Work
In [15], Gava considered the correctness proofs of BSML programs. The main diÔ¨Äerence on the formalisation
of BSML semantics in his work and ours is that we axiomatised the semantics of BSML in a module type which
allows us to implement a module with this type to ensure the consistence of our development with Coq‚Äôs logic. We
also heavily rely on the Program mechanism of Coq that was not available in 2003. Finally we applied the updated
framework to develop a new application and to study the performance of the extracted BSML program.
For sequential languages, the traditional way for verifying programs is based on a VeriÔ¨Åcation Condition Generator
(VCG). The user annotates the source code with assertions that describe pre and post conditions as well as invariants.
The VCG tool extracts proof obligations from programs with annotations. The program is correct, i.e. it is guaranteed
to satisfy its speciÔ¨Åcation, if the proof obligations can be proved correct. The Spec# [16] and Why [17] systems follow
this approach. [18] built on Why with the intent to prove BSP programs similar to C programs with BSPlib [19] calls.
It is also possible to directly use a proof assistant to verify programs. One can rely on a deep embedding: programs syntax and semantics are represented by inductive data-types in the proof assistant. This technique is quite
heavy for proving the correctness of programs, but is adequate for reasoning about the semantical properties of a
programming language. The approach we choose is to use a shallow embedding: the logic of proof assistants is a kind
of programming language. It is thus possible to write both programs and assertions in the same language and prove
the correctness of programs. This is also the approach taken in the CompCert project [7] for the veriÔ¨Åcation of an optimising C compiler. However the programming languages of proof assistants have limitations. For example it is not
possible to write programs with eÔ¨Äects. Ynot [20] relies on a dependently-typed monad for describing computations
with eÔ¨Äects. Nevertheless the authors indicate in [21]: ‚ÄúHowever, the pack injectivity axiom contradicts the axiom of
proof irrelevance (which we do not use in any of our developments, but which is popular among Coq users), and it
is an open question in the Coq community whether this axiom is consistent with Coqs logic even by itself.‚Äù which is
problematic.
A third approach has been recently developed [22]. From a real programming language source code (here Objective Caml), a logical formula is generated. This logical formula applied to a speciÔ¨Åcation gives a suÔ¨Écient condition
for establishing that the program satisÔ¨Åes the speciÔ¨Åcation.
A last approach is to avoid a posteriori veriÔ¨Åcation by building correct-by-construction programs. It is the approach taken in constructive algorithms [23]. An eÔ¨Écient program is derived step-by-step through a sequence of
transformations that preserve the meaning and hence the correctness. Program calculation can be used for writing
parallel programs [24] with suitable data-structures. The program is then implemented using a parallel library of algorithmic skeletons, which is not proved correct: there is a semantical gap between the Ô¨Ånal composition of algorithmic
skeletons obtained by derivation and its implementation. We also experimented with this kind of approach, but without
the drawback, with a new kind of homomorphism and a Coq framework to derive BSML programs from speciÔ¨Åcations
through program transformation [25] and then extraction. The present work complements this approach: all BSML
programs cannot be written eÔ¨Éciently as an instantiation of this new homomorphism.

Julien Tesson and Fr√©d√©ric Loulergue / Procedia Computer Science 4 (2011) 36‚Äì45

45

8. Conclusion and Future Work
In this paper we present a framework within the Coq proof assistant to develop correct Bulk Synchronous Parallel ML programs. Actual BSML programs can be extracted from the proofs. In particular we develop a simulation
application based on the heat equation, and proved the correctness of both the sequential and parallel versions of the
simulation with respect to the discretised (by Ô¨Ånite diÔ¨Äerences) equation. Preliminary results show that the performances of extracted programs are acceptable, even if there is room for improvement.
We are currently working on a certiÔ¨Åed implementation of the pure functional subset of the BSML standard
library. We also plan to develop new applications and experiment with them. In the long term we will consider a
veriÔ¨Åed compiler for the Bulk Synchronous Parallel ML language. If the correctness of the compilation and execution
of a BSML program cannot be ensured, the eÔ¨Äort to prove the correctness of programs is undermined. We will build
this compiler using the MLCompCert compiler [26] for sequential ML.
9. References
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12]

[13]
[14]
[15]
[16]

[17]
[18]
[19]
[20]
[21]

[22]
[23]
[24]
[25]

[26]

S. Gorlatch, Send-receive considered harmful: Myths and realities of message passing, ACM TOPLAS 26 (1) (2004) 47‚Äì56.
M. Cole, Algorithmic Skeletons: Structured Management of Parallel Computation, MIT Press, 1989.
L. G. Valiant, A bridging model for parallel computation, Comm. of the ACM 33 (8) (1990) 103.
F. Loulergue, F. Gava, D. Billiet, BSML: Modular Implementation and Performance Prediction, in: V. S. Sunderam, G. D. van Albada,
P. M. A. Sloot, J. Dongarra (Eds.), International Conference on Computational Science (ICCS), LNCS 3515, Springer, 2005, pp. 1046‚Äì1054.
The Coq Development Team, The Coq Proof Assistant, http://coq.inria.fr.
P. Letouzey, Coq Extraction, an Overview, in: A. Beckmann, C. Dimitracopoulos, , B. L¬®owe (Eds.), Logic and Theory of Algorithms, Fourth
Conference on Computability in Europe, CiE 2008, LNCS 5028, Springer, 2008.
X. Leroy, A formally veriÔ¨Åed compiler back-end, Journal of Automated Reasoning 43 (4) (2009) 363‚Äì446.
doi:10.1007/
s10817-009-9155-4.
The BSML Development Team, The BSML Library version 0.5, https://traclifo.univ-orleans.fr/BSML (august 2010).
F. Gava, F. Loulergue, A Static Analysis for Bulk Synchronous Parallel ML to Avoid Parallel Nesting, Future Generation Computer Systems
21 (5) (2005) 665‚Äì671.
X. Leroy, D. Doligez, A. Frisch, J. Garrigue, D. R¬¥emy, J. Vouillon, The Objective Caml System release 3.12, http://caml.inria.fr
(2010).
F. Loulergue, Parallel Superposition for Bulk Synchronous Parallel ML, in: P. M. A. Sloot, al. (Eds.), International Conference on Computational Science (ICCS 2003), LNCS 2659, Springer Verlag, 2003, pp. 223‚Äì232.
W. Bousdira, F. Gava, L. Gesbert, F. Loulergue, G. Petiot, Functional Parallel Programming with Revised Bulk Synchronous Parallel ML, in:
K. Nakano (Ed.), First International Conference on Networking and Computing (ICNC 2010), 2nd International Workshop on Parallel and
Distributed Algorithms and Applications (PDAA), IEEE Computer Society, 2010, pp. 191‚Äì196. doi:10.1109/IC-NC.2010.57.
The Coq Proof Assistant, http://coq.inria.fr.
M. Sozeau, Un environnement pour la programmation avec types d¬¥ependants, Ph.D. thesis, University Paris East, LRI (2008).
F. Gava, Formal Proofs of Functional BSP Programs, Parallel Processing Letters 13 (3) (2003) 365‚Äì376.
M. Barnett, K. R. M. Leino, W. Schulte, The Spec# programming system: An overview, in: G. Barthe, L. Burdy, M. Huisman, J.-L. Lanet,
T. Muntean (Eds.), Construction and Analysis of Safe, Secure, and Interoperable Smart Devices (CASSIS), LNCS 3362, Springer, 2004, pp.
49‚Äì69. doi:10.1007/978-3-540-30569-9_3.
J.-C. FilliÀÜatre, C. March¬¥e, The Why/Krakatoa/Caduceus Platform for Deductive Program VeriÔ¨Åcation, in: W. Damm, H. Hermanns (Eds.),
19th International Conference on Computer Aided VeriÔ¨Åcation, LNCS, Springer, 2007.
J. Fortin, F. Gava, Bsp-why: an intermediate language for deductive veriÔ¨Åcation of bsp programs, in: Proceedings of the fourth international
workshop on High-level parallel programming and applications, HLPP ‚Äô10, ACM, 2010, pp. 35‚Äì44. doi:10.1145/1863482.1863491.
J. M. D. Hill, B. McColl, D. C. Stefanescu, M. W. Goudreau, K. Lang, S. B. Rao, T. Suel, T. Tsantilas, R. Bisseling, BSPlib: The BSP
Programming Library, Parallel Computing 24 (1998) 1947‚Äì1980.
A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, L. Birkedal, Ynot: dependent types for imperative programs, in: J. Hook, P. Thiemann
(Eds.), 13th ACM SIGPLAN international conference on Functional programming (ICFP 2008), ACM, 2008, pp. 229‚Äì240.
A. J. Chlipala, J. G. Malecha, G. Morrisett, A. Shinnar, R. Wisnesky, EÔ¨Äective interactive proofs for higher-order imperative programs, in:
G. Hutton, A. P. Tolmach (Eds.), 14th ACM SIGPLAN international conference on Functional programming (ICFP 2009), ACM, 2009, pp.
79‚Äì90. doi:10.1145/1596550.1596565.
A. Charg¬¥eraud, Program veriÔ¨Åcation through characteristic formulae, in: P. Hudak, S. Weirich (Eds.), 15th ACM SIGPLAN international
conference on Functional programming (ICFP 2010), ACM, 2010, pp. 321‚Äì332. doi:10.1145/1863543.1863590.
R. Bird, O. de Moor, Algebra of Programming, Prentice Hall, 1996.
K. Morita, A. Morihata, K. Matsuzaki, Z. Hu, M. Takeichi, Automatic Inversion Generates Divide-and-Conquer Parallel Programs, in: ACM
SIGPLAN 2007 Conference on Programming Language Design and Implementation (PLDI 2007), ACM Press, 2007, pp. 146‚Äì155.
L. Gesbert, Z. Hu, F. Loulergue, K. Matsuzaki, J. Tesson, Systematic Development of Correct Bulk Synchronous Parallel Programs, in: The
11th International Conference on Parallel and Distributed Computing, Applications and Technologies (PDCAT), IEEE Computer Society,
2010, pp. 334‚Äì340. doi:10.1109/PDCAT.2010.86.
Z. Dargaye, X. Leroy, A veriÔ¨Åed framework for higher-order uncurrying optimizations, Higher-Order and Symbolic Computation 22 (3)
(2009) 199‚Äì231.

