Available online at www.sciencedirect.com

Procedia Computer Science 18 (2013) 1824 ‚Äì 1833

International Conference on Computational Science, ICCS 2013

A tool for selecting the right target machine for Parallel ScientiÔ¨Åc
Applications
Javier Panadero1 , Alvaro Wong, Dolores Rexachs, Emilio Luque‚àó
Computer Architecture and Operating System Department, Universitat Autonoma de Barcelona, Barcelona, SPAIN.

Abstract
Analyzing and predicting performance in parallel applications is a great challenge for scientiÔ¨Åc programmers due to its complexity. Analyzing parallel application behavior is not a trivial process and it requires spending a large amount of time and
eÔ¨Äort to understand the behavior of the application algorithms during execution. We have developed PAS2P toolkit from
PAS2P methodology. This methodology strives to characterize the behavior of MPI applications to identify and extract representative phases and create a signature, which will be used to analyze the application behavior and predict its execution time
in diÔ¨Äerent target systems. Applying this methodology is a non-trivial process for users, for this reason we have developed the
proposal toolkit, which allows users to make the whole process, from creating a signature to executing it on target systems, in
user-space in an easy and fully automatic way. PAS2P toolkit has been validated, making clear the advantages of the signature,
with its execution time being much lower than the whole application execution time (around 7% of the total execution time),
with a high quality prediction of around 96%.
Keywords: Performance toolkit, Performance Prediction, Parallel Application Signature

1. Introduction
The continuous progress in parallel machines as well as in parallel programming models have allowed the
development of scientiÔ¨Åc applications with more complexity and accuracy. These kinds of applications are very
diÔ¨Écult to analyze, due to their high level of complexity, which centers on the diÔ¨Éculty to understand the behavior
of the application during its execution in order to Ô¨Ånd and isolate performance problems. Moreover, parallel
applications can be executed using diÔ¨Äerent systems and diÔ¨Äerent performance results can be obtained, according
to the machine conÔ¨Åguration. In performance prediction, the best way for measuring the performance is to use
the application itself, but the time required to run it thoroughly is a heavy requirement; especially if we want to
predict in diÔ¨Äerent systems. In this sense, performance tools become necessary to determine the most suitable
system on which to execute the application.
The Parallel Application Signature for Performance Prediction (PAS2P) methodology[1] strives to solve the
complexity of the behavior analysis making an application signature, which represents the relevant behavior of a
‚àó

Email addresses: javier.panadero@caos.uab.es (Javier Panadero), alvaro.wong@caos.uab.es (Alvaro Wong),
dolores.rexachs@uab.es (Dolores Rexachs), emilio.luque@uab.es (Emilio Luque)
1 Corresponding author. Tel.: +34-93-581-1990 ; fax: +34-93-581-2478.

1877-0509 ¬© 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
Selection and peer review under responsibility of the organizers of the 2013 International Conference on Computational Science
doi:10.1016/j.procs.2013.05.351

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833

1825

message passing application. The signature is built by selecting a set of relevant parts (phases) and their weights,
which are the frequency each phase repeats. When the signature is constructed, it can be executed on real target
machines in order to analyze its behavior, as well as to predict the execution time with a high degree of accuracy.
We propose to make a toolkit in order to automate the PAS2P methodology to facilitate its usability, because
to obtain and execute the signature from the methodology is a non-trivial process for the users. In this sense,
we have developed a toolkit from PAS2P methodology named PAS2P toolkit, which automatically generates an
application signature transparently in order to be executed in real target machines.
PAS2P toolkit can be employed by system administrators, users and scientiÔ¨Åc programmers. System administrators need foresight which allows them to make better use of the available resources, through mapping policies
with the purpose of reducing economic and energy costs. On the other hand, users want to execute their applications as fast as possible in order to obtain their results, thus they need to know what system is more appropriate to
execute their applications, whereas scientiÔ¨Åc programmers need to know the performance and the behavior of an
application in order to optimize it and solve any performance problem. Due to the fact that the signature represents
the application kernel, programmers can focus on analyzing the signature behavior, which contains the important
pieces of code, with the aim of detecting application performance problems.
To develop the PAS2P toolkit, all stages of the PAS2P methodology have been implemented. The toolkit
we propose is composed of four modules: Instrumentation, Analysis, Signature construction and Performance
prediction. In the instrumentation module, we collect the data and characterize compute and communication
behavior to generate an application trace log. The analysis module is developed to obtain the application model
to identify and extract the most relevant phases and assign them a weight from the number of times they occur.
For the Signature construction, we generate an executable signature, which contains the relevant phases and their
weights. Finally, the Prediction module was developed, which executes the signature to predict the execution time
in an automatic way.
To evaluate the correct implementation of the proposed PAS2P toolkit, a set of experiments were carried out
extracting the signatures from benchmarks such as CG, BT and LU from NPB [2], Sweep3D [3] and SMG2000
[4], and the applications Moldy [5] and M.DynaMix [6]. The signatures generated with the PAS2P toolkit for all
the applications tested have an average execution time that represents about 7% of the application execution time,
and the prediction quality is about 93% accurate, ensuring the two objectives of PAS2P methodology.
This paper is organized as follows: Sections 2 and 3 present related work and the PAS2P methodology, respectively. Section 4 presents the PAS2P toolkit, Section 5 presents the analysis and discussion of the prediction
results obtained, and Ô¨Ånally, we present the conclusions and future work.
2. Related Work
There are other tools which are closely related to analysis and performance prediction. WARPP [7] is a prototype semi-automatic performance prediction simulator, which was designed to support the automated generation
of performance models and it is composed of four steps: (1) model construction which requires signiÔ¨Åcant work
by the user, (2) machine benchmarking an instrumented version of the application, (3) post-execution analysis
of machine benchmarking results to produce simulator inputs and Ô¨Ånally (4) simulation. This approach diÔ¨Äers
from PAS2P toolkit because with our toolkit, users can generate and execute the application signature in a fully
automatic way in order to obain the performance prediction.
There are other approaches such as BSIM [8] and PHANTOM [9] which also use simulation in order to predict
the performance. BSIM is a simulator that predicts the performances for a parallel application by the simulation of
only the communications, the computing parts of the program are modeled separately. In PHANTOM, the performance estimation is based on the real execution of computational parts of all processes of the parallel application
on a single machine of the platform. The resulted computing performances will be combined with the network
performances by the use of MPI-SIM [10] in order to predict the parallel execution time. This approach diÔ¨Äers
of PAS2P toolkit since PAS2P generates an application signature which contains the most signiÔ¨Åcant application
parts (communication and computation) in order to be executed in real target machines.
SWAPP [11] is a framework for performance prediction based on computation and communication projections
and using benchmark data in target systems. The framework assumes that the target system is not available for

1826

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833

running applications, only benchmark. Projections are developed using the performance proÔ¨Åles of the benchmarks and application on the base system and the benchmark data for the target system. SWAPP projects the
performances of compute and communication components separately, then they are combined to get the full application projection. This approach diÔ¨Äers from PAS2P toolkit since PAS2P does not use benchmark information
to predict the application performance, instead the application signature is executed in the target sytem.
Snavely et.al. [12] proposes a framework to construct application and machine signatures to simulate application behavior across diÔ¨Äerent system or processor architectures. In order to project the MPI communication
performance, the Dimemas simulator [13] is used. This approach diÔ¨Äers of PAS2P toolkit, since our toolkit uses
a real network in order to obtain the communication performance.
3. Overview about PAS2P methodology
Applications typically possess highly repetitive behavior and parallel applications are no exception. PAS2P
makes an analysis to characterize the computational and communications-related behavior of parallel applications
by identifying these repetitive portions. It is important to notice that this is a two-step methodology. The Ô¨Årst step
is to analyze the application, build the application model to extract its phases and weights, and use that information
to build the signature, which is an executable that contains the relevant phases with instrumentation. This is in
order to have information about their behavior and their weights to predict the application performance on the
target machines. The second step is to execute the signature in a target system, to measure the execution time of
each phase and predict the execution time of the application.
3.1. Application analysis and signature construction
In order to obtain the behavior of computation and communication, the application is instrumented on a base
machine in order to intercept and collect communication events of the parallel application. With this collected data
an application trace log is generated. The communication events are ordered by means of a logical global clock
according to causality relations between communication events. The machine-independent application model
can be obtained from this trace. Once we have the application model, the methodology strives to identify the
application patterns in order to Ô¨Ånd a representative behavior of the application. It is processed using a technique
that searches for similarity to identify and extract the most relevant event sequences (phases) and assign them a
weight based on the number of times the phases occur. Afterwards, in order to construct the signature, the last step
is to re-run the application to create the coordinated checkpoints before each relevant phase happens. Therefore,
the executable signature will be deÔ¨Åned by a set of relevant phases and their weights.
3.2. Performance prediction model
Once we have constructed the application signature, we can run it on real target machines to analyze the
application behavior and predict the application execution time. In order to execute the phases, we restart the
checkpoints of the application before the phase begins and measure its execution time until the phase ends. In order
to predict the application execution time equation 1 is used, where PET is the Predicted application Execution
Time, n is the number of phases, TEPhasei is the Phase i Execution Time and Wi is the weight of the phase i.
Due to the complexity of the process and the huge quantity of information obtained during the analysis, we
decided to automatize the methodology, allowing users to apply the whole methodology in an automatic and
transparent way. The next section explains how the methodology was automated.
n

PET =

(T EPhasei)(Wi)

(1)

i=1

4. PAS2P Tookit
We have developed a toolkit from PAS2P methodology, named PAS2P toolkit, because obtaining and executing
the signature from the methodology is a non-trivial process for the users. PAS2P toolkit allows users to generate
and automatically execute an application signature transparently.

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833

1827

The PAS2P methodology has been grouped into four independent modules. The Ô¨Årst three modules: Instrumentation, Analyzer and Signature generation are related to the Ô¨Årst step of the PAS2P methodology, which was
explained in section 3.1, while the fourth module, the Performance prediction module, is related to the second
step of the methodology, which was explained in section 3.2. All four modules have been integrated in a toolkit.
Figure 1 shows a chart representing each module and the stage of the methodology that is developed in it.
Instrumentation
Module

Analyzer
Module
Trace Log (Input)

Instrume
Inst
rumentat
rume
ntation
ntat
ion
(Extract
(Ext
ract Log tra
trace)
ce)

User inp
User
put
p meters
para
et

Execute
Exec
ute Appl
pp icat
ication
ion

Parallel
ralle
Application Model

D t coll
Data
collllect
lecti
e tion
ion
(Trace Log))
(Trace
(Tra

Patterns
ttern
identification
ifica
Table
Tabl
e of
of re
relevan
rel
levan
evantt
Phases
Phas
Ph
es and
d
W ight
Weig
hts

Dynamic library
libpas2p

Binary
Pas2p_tool

Signature Generation
Module

Performance Prediction
Module

Table of relevant
Phases and Weights

Execute
Exec
t sign
ig atur
ature
t e

PAS2P Instrumentation
strum
Extract binaryy Phases

Measure phases

Execute
Exec
t App
Appl
A
pp
pllicat
i tion
icati
ion
(save st
(sav
states
ates))
ates

Prediction model

Applicat
Appl
i tion
icati
ion S
Sign
Si
g atur
ature
t e

Predicti
Pred
iction
icti
on
executio
exec
ution
utio
n time
time

Dynamic library
libpas2p

Dynamic library
libpas2p

Fig. 1. Modules of PAS2P toolkit

PAS2P toolkit is composed by two binaries, Pas2p command and Pas2p tool. These binaries have been developed in C++ in order to take advantage of the eÔ¨Éciency of C and the facilities of C++, as the Standard Template
Library (STD). The binary Pas2p command allows us to automate the whole process until the executable signature is created. Fig. 2 shows all the options of Pas2p command and how users can use it. The binary Pas2p tool
analyzes the log trace to obtain the relevant phases and their weights. Besides these two binaries, the PAS2P
toolkit has a dynamic library called Libpas2p, which allows us to automatize the methodology by instrumenting
the application, constructing and executing the signature.
& 3%!6)1++8*8,
+5*+!7-,,
*+!7-,++ 2 % #2
%! "'!" !2 %#2
00000000000000000000000000000000000000000000000
7
	

,7	
,!" %""% %!"!.
/
, !" %""% '"%""!
00000000000000000000000000000000000000000000000
& 3%!6)1++8*8,
+5

Fig. 2. Pas2p command user interface

4.1. Instrumentation module
With the purpose of instrumenting the parallel message application, we generate an optimized trace log containing necessary information such as communication events and computational time. To do this transparently,
the dynamic library named Libpas2p was developed and located between the parallel application and the MPI
library. Its objective is to intercept and collect MPI communications primitives during the application execution
time by interposition functions, without modifying the application source code. These primitives will be saved
as communication events and computational time to build a trace log. In order to obtain the trace log, the binary
Pas2p command is used with the input parameter ‚Äù-l ‚Äù, which loads the Libpas2p in user space automatically
through the environmental variable LD PRELOAD, as is shown in Fig. 3(a). Once the application has been executed, the trace log is obtained. As is shown in Fig. 3(b), the trace log contains information about the application
process, on column 1 (process), the MPI event, on column 2 (Call), the source/
e destination of the process involved
with, on column 3 (Send/
d Recv), the count events per process, on column 4 (Count), the communication volume

1828

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833

in bytes, on column 5 (Byte), the wall clock time in nanoseconds, on column 6 (Wtime), the computational time
in nanoseconds, on column 7 (Compute Time), which is deÔ¨Åned by the cpu time between two MPI events, and
Ô¨Ånally the type of the event (send: 1, recv: 0, collective: -1). This trace log will be used in the next module in
order to construct the application model.
(" 7'#=-500?.?2
09..0..0!#>!00!#>!3 26!"'2! @..@/
4444444444444444444444444444444444444444444444444444444444444444444444444444444
444
>

444
4444444444444444444444444444444444444444444444444444444444444444444444444444444
>	
) -0'#"0 00!"'2*	3	2! @..@1$!#>!3 '$!'$. 
""#?.?22"
+-CA<<<
$"% #-CA
'" %(!" ###@
'"  +" #!"" )- =?
('#-
.B<<F<>
$"% 
+$
=<.>>AC<AE?D<@ECC2=> AE.EEE@CA=ACDCA@
><.DCE@<A>A==<><A2=A >=.CB>CD@B=@>A?@

Process

Call

Send/
Recv

Count

Byte

Wtime

Compute
Time

Type

0

MPI_ISend

1

1

4000

0.00128

8876

1

0

MPI_Waitall

1

2

4000

0.00157

704

0

0

MPI_ISend

1

3

2000

0.00201

1208299

1

0

MPI_ISend

1

4

4000

0.05507

13851

1

0

MPI_Waitall

1

5

4000

0.05529

7615

0

0

MPI_ISend

1

6

2000

0.05549

3790

1

0

MPI_Waitall

1

7

2000

0.05595

3502

0

Fig. 3. (a) Pas2p command loads the Libpas2p library to obtain the application trace log; (b) Trace log generated by Libpas2p library.

4.2. Analyzer module
In order to extract the relevant phases of the application and their weights, the analyzer module is used. This
module is composed of the binary Pas2p tool, which is executed automatically by Pas2p command when the trace
log is obtained, as is shown in Fig. 4(a).
2225!!!! ,0!0)#!0 0"$5"0 0"$5"1%!!222
222222222222222222222222222222222222222222222222222222222222




			

		

$5"1%!!
!"(%##%%(# "#& 

*$%"#% %

 )#$ (%! ! #! 
222222222222222222222222222222222222222222222222222222222222
$.0"$5"1%!!<"$5"! %#=< !1 %#&)=-		
#$  %...
 $5"
!...

!
%#& 5!## ...
 $...
#!$$$-7
#& ""&! !...48;96&$.

*$"6)%;/51!1=0=2	1!801#%<#3&""& #0#%<#
444444444444444444444444444444444444444444444444444444444444




			
		
%<#3&""
" #)&$$&&)$!#$'!
+%& #$& !&
!*$%)&"!"  $"!
444444444444444444444444444444444444444444444444444444444444
%01#%<#3&""B#%<#3CB!"3!&$'*C/		
"

)!'"! % $&+.)&/>:A.!-%1"/


!%#! .
# !#$#%*/
5!( -:"$$

" #)&'"! % $&+.)&/>:A.!- %1"/
$%!&000
!%<#
"000

Fig. 4. (a) Pas2p command loads the analyzer Pas2p tool after the application ends; (b) Users can modify the input parameters of similarity.

Pas2p tool has as input the application trace log created in the instrumentation module, as well as two user
parameters: computation and communication similarity, as is shown in Fig. 4(b). The computation parameter
compares the computational time between two phases, where a value of 100% represents the equality between the
phases. As for the communication parameter, Pas2p tool compares which type of communication there is and the
number of similar communication events. The user can conÔ¨Ågure these two parameters, modifying their range of
similarity. These ranges of similarity determine the total number of application phases.
The parser of the analyzer module reads the trace log, where all events are collected into an event vector, which
will be analysed later to obtain the parallel application model. Once the event vector has been Ô¨Ålled, it needs to
relate the events that belong to the same message. This id relation is done using bit Ô¨Åelds. If two events contain
the same id relation, then they will be related to each other, this relation being the source, destination and/
d or size
of each event.

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833

1829

To obtain the application model, we Ô¨Årst have to assign the Logical Time (LT). To assign Logical Times to each
event, the algorithm proposed in the PAS2P methodology is used. This algorithm was improved by eliminating
searches, creating structures that allow pointing the memory position where events are aiming to decrease the
time to assign logical time to each event. Once the LT of the events are assigned, a new vector is created, named
Logical Model, with a speciÔ¨Åc size, deÔ¨Åned by the number of processes per the maximum LT in which all events
are inserted in a position depending on their LT. Once the events are inserted, the index of the vector itself is used
as Logical Clock (Tick).
Taking the algorithm proposed in the methodology, the Logical Trace vector goes forward to generate phases
and compare them. In order to obtain the phases, we generate another vector called Phases vector, which contains
the following information:
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢
‚Ä¢

Communication Pattern: The processes (source / destination) involved in the phase.
Communication Volume: The volume of communication sent or received in the phase.
Startpoint: The tick where the phase begins
Endpoint: The tick where the phase ends
Phase Execution Time: The computational time from the startpoint to the endpoint.
Phase Weight: Number of times that the phase repeats

To compare the phases to decide if two phase are similar, Pas2p tool considers the next Ô¨Åelds of the Phases
vector: communication pattern, communication volume and phase execution time. If these three Ô¨Åelds are similar,
the phases will be the same and the phase weight Ô¨Åeld increases one unit.
Once the phases have been obtained, the next step is to select the relevant phases. These phases are selected
by their percentage of representativeness. Pas2p tool generates three ranges of predictions (85-90%,90-95%,95100%) selecting diÔ¨Äerent phases, as is shown in Fig. 5(a). The prediction error will be given by the number of
phases, a higher number of phases implies less error, but a higher signature execution time. Users can select any
of these prediction ranges, by default Pas2p tool selects the highest range of prediction (95%-100%).
.!%3
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
.
	

!()5/&24458&
"%-
#!()%3/&4040

#!()%34&4./-

Weights 
	!!



04



-1,
.1.





Execution time

R
Relevant
Phases
P

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
.
	&

!()53&34-58&
"%.

#!()%33&,303

#!()%34&4./-

	!!
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
.
	

!()54&53258&
"%/

#!()%34&,-22

#!()%34&4./-

	!!

8
"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

")!/#(%%
1$1&	%+ '
&/
/
&/
1
14141414
2.2.2.2. ./754
4
141414142.2.2.2../754
0    
2 2. 2. 2. 20 20 20 20 / 0..6
2.
6
6
2.2.2.2.20202020/0..6
/012 /012
3
20202020222222220/753
4
2222222226262626./754
6
262626263.3.3.3./0..6
3.3.3.3.303030300/753
   
3030303034343434./754
 
3434343436363636/0..6

363636364.4.4.4.0/753
4.4.4.4.42424242./754
 
4242424244444444/0..6
44444444464646460/753
4646464650505050./754

Fig. 5. (a) Users can select the set of phases in order to construct the signature; (b) Pas2p tool build a table of phases to construct the signature.

Finally, the relevant phases and their weights are saved in a phase table. Fig. 5(b) shows an example of this
table, which was obtained from the execution of an application with 4 processes and contains the startpoint and
endpoint of each phase that will be used to measure its execution time. Each row of the table represents a phase,
whose startpoint and endpoint are deÔ¨Åned by the number sent where the phase occurs. The last two columns show
the Phase ID and the weights of the phase. After the phase table is generated, Pas2p tool indicates if it is necessary
to construct the signature making checkpoints or not depending on where the relevant phases are located in the
application.

1830

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833

4.3. Signature generation module
Once Pas2p tool has obtained the relevant phases and their weights, users can use this module to generate the
executable signature.
The Ô¨Årst step to construct the signature is instrument the application, due to the interaction between the application with external libraries. If the signature has to be constructed with checkpoints, we have to guarantee
a correct warm-up time for the machine components. Another issue is how to detect relevant phases during the
application execution. Due to the complexity of this step, we add the process of signature generation to the Libpas2p library to make it transparent to users. To construct the signature, the binary Pas2p command is used, which
re-runs the application loading the Libpas2p library and the phase table to instrument and detect where the phases
occur. Once the signature has been constructed, an executable named signature is generated in order to predict
the performance prediction. Now we describe both processes.
‚Ä¢ Signature with checkpoints. To create the signature with checkpoints the binary Pas2p command is used
with the input parameter ‚Äú-c‚Äú. The checkpoint operation is done before the Startpoint of the phase to
guarantee the warm-up. Previous versions of the Ô¨Årst PAS2P implementation used the BLCR library[14],
but it requires being installed at the kernel level, therefore we changed to the DMTCP [15] checkpointing
library, because of its user-level transparency. As shown in Fig. 6(a), the Libpas2p detects a phase and calls
the DMTCP library to make the checkpoint. Once it is done, the DMTCP returns the control to the Libpas2p
to add the checkpoint to the signature. This process is repeated until the last relevant phase. Finally, the
executable signature is generated, with the information needed to measure each phase. Fig. 6(b) shown
an example of signature generation using checkpoints. We know that the size of the checkpoint could be a
big problem, depending of the application memory requeriments. In order to reduce the checkpoints size,
the DMTCP library has an option to compress the size of checkpoint, which the module achieves reducing
the checkpoint size signiÔ¨Åcantly. Moreover, in the cases that the relevant phases are at the beginning of the
application, the signature can be constructed avoiding the use of checkpoint.









	









	









>		

$""#35$"5!,&$5#5"(%5#5"(%7 %$#(66%&.5$"5!,&$5#5"(%5+'&5!$!5#5
"%&+#6.76.	76.7
	7	6#%@44@
"(%7$$&#($&'(&)#444
$&(3CCCD
 %$#(	#(&,!3'!8 %$#("#+!!/#'(9
.($#!'(!#(3=
 &$+##444

:::>			:::


&!!!#"& '?4?66#"& 

03CA<<<
	(&)$#'3CA
+"&$),%&$'''3@
+"&$#$#0&$'%&&$-3=?
#,!+'34B<<E<>

 %$#(&'+!(%$'),&$''3<


		<

:::		&+#45'#(+&4':::

>$#2	#(&&+"%#.+)$#444

			
	=A'$#'4

Fig. 6. (a) Libpas2p calls to DMTCP API to make checkpoint; (b) Pas2p command re-run the application to construct the signature.

‚Ä¢ Signature without checkpoints. In the case that the relevant phases appear at the beginning of the application
and they are repeated throughout all the execution, it is possible to avoid checkpoints to construct the
signature. In that case, users can use Pas2p command with the input parameter ‚Äú-r‚Äú. It is important to
remark that although only a relevant phase appears distant at the beginning of the application, it would
be necessary to do checkpoints in order to avoid executing the application until this relevant phase arrives
during the performance prediction stage. The signature is generated with the phase table loaded with the
Libpas2p obtained during the analysis module to detect where each phase begins and ends.

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833

1831

4.4. Performance prediction module
Once the signature has been constructed, users can run the executable signature on target machines. It is
important to remark that in order to predict the application execution time, the signature will execute and measure
each phase. The execution time obtained in each phase will be multiplied by the weight of its phase, as shown
in equation 1 in section 3.2. It is for this reason that the signature is composed of the phases and their weights.
Besides, indistinctively from the system where it is executed, users can execute the executable signature using
diÔ¨Äerent mapping policies. In that case, users can use a machine Ô¨Åle if they want to predict the performance by
changing the mapping policies of the processes on diÔ¨Äerent nodes or cores.



















 



	


	






(" 6'#<.500>/>1
	08/0#$'"/#
$!2 "$ "#$"%///
 "$.BBBD
! $	$"(.#3! $'*#$4
)$ #$$.<

$'"#+.=B?
/

	;
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE



=	
	




$"$"$
$ ///
$///

#.;$.<DBA
#)'% .;/;;==D;#/

#.<$.<DB?
#)'% .;/;;;C?D#/

#.=$.<DB@
#)'% .;/;>A@BC#/

"$)'% 34.BC/??<><B#/
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE

= -	$""'!)'% ///
			
?# #

Fig. 7. (a) Libpas2p restarts checkpoints; (b) Execute the signature in order to predict.

‚Ä¢ Execution with checkpoints. The checkpoints of the signature are restarted from the saved states and start
measuring from the point where a phase begins until its end. In order to detect a phase the library Libpas2p
is used. When a phase is measured, the signature Ô¨Ånalizes its execution and restarts the next checkpoint
using the DMTCP library. This method and process is repeated for all phases, as is shown in Fig. 7(a). The
PAS2P toolkit uses a non-blocking method once the phase ends to Ô¨Ånalize the checkpoint execution. This
is done generating messages where all processes inform to process 1 that they have Ô¨Ånished. When process
1 has been measured, a MPI testall is carried out to check if all processes have sent the message to Ô¨Ånalize
the execution. Finally, the signature applies the equation 1 in order to predict the execution time. Fig. 7(b)
shows the signature execution output where the performance prediction using checkpoints can be observed.
‚Ä¢ Execution without checkpoints. In this case, the signature is built without checkpoints. This is because the
relevant phases are located at the beginning of the application. The signature runs the parallel application
from the beginning and is measured from where a phase begins until its end. When the last phase has been
measured, the signature Ô¨Ånalizes the application and applies the equation 1 in order to predict the execution
time.
5. Experimental results
With the objective to demostrate the operation of PAS2P toolkit, we show some experimental results on diÔ¨Äerent clusters used as base and target machines (see Table 1). We present the results obtained for the following parallel programs: CG, BT and SP from the NPB using class D, Sweep3D (workload sweep 150), SMG2000 (workload -n 250 -solver 3 - iterations 1200), Moldy (Workload control.tip4p with nsteps=100000) and M.DynaMix
(iterations=150 and 2000 molecules H2O). All the applications have been compiled using 256 processes.

1832

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833
Table 1. Cluster characteristics
Cluster
IBM Cluster
(Target Machine)
Nova Cluster
(Base Machine)

Characteristics
Dual-Core Intel(R) Xeon(R) CPU 5160 2.66GHz 4MB L2 (2x2),12 GB Fully
Buffered DIMM 667 MHz, Interconnection Gigabit Ethernet, 128 cores.
4 Intel Xeon quad-core E7350 2.66Ghz Tigerton Processors L2 cache= 2x4 MB
16 cores (total = 256 cores) 48 GB DDR2 SDRAM, Interconnection Infiniband ConnectX IB Mellanox card

In order to construct the signature, the binary Pas2p command was used. Pas2p tool has been executed with
the input parameters of similarity by default, considering a relevant phase when its time is 1% greater than the
application execution time. When we analyzed the mentioned applications, Pas2p tool informed us that we could
construct the signature without checkpoints, since all these applications have the relevant phases at the beginning
of the execution, but in order to show the diÔ¨Äerence between both options, we constructed the signature both with
and without checkpoints.
We constructed the signatures in the Nova Cluster (Base machine) and executed the signature of each application in the same cluster and in the IBM Cluster as target machines to predict the application performances.
The execution results on Nova Cluster are illustrated in Table 2. The SET column shows the Signature Execution Time, while AET column shows the Application Execution Time. In the SET vs. AET column is shows the
percentage value of SET with respect to the AET. Then, the PET column shows the Predicted Execution Time,
once the signature has been executed and Ô¨Ånally results in the PET and AET columns being compared to obtain
the Prediction Error. With these results, we obtain the SET around 6% of the Application Execution Time (AET),
with a minimum prediction quality of 93.6%.
We also executed the signature of each application in the IBM Cluster, used as target system, to predict the
Application Execution Time, as shown in Table 2. The applications have been fully executed in order to evaluate
the quality of the prediction, and the prediction results are very similar to the execution in the Nova Cluster with
a maximum predicted error of 6.4%.
Table 2. Predictions in cluster NOVA and cluster IBM
Application

Cores

CG-256
BT-256
SP-256
SMG2000-256
Sweep3D-256
Moldy-256
M.DynaMix-256

256
256
256
256
256
128
128

CG-256
BT-256
SP-256
SMG2000-256
Sweep3D-256
Moldy-256
M.DynaMix-256

128
128
128
128
128
128
128

Signature execution using Cluster NOVA as target Machine
Signature Exec T.
SET vs. AET (%)
Predicted Exec. T.
Prediction
(SET) (Sec)
(PET)(Sec)
Error (%)
16.81
4.04%
400.80
3.4%
6.38
1.37%
492.31
6.4%
5.72
0.62%
877.79
3.4%
134.30
1.76%
7305.97
3.8%
81.72
7.35%
1042.01
6.2%
31.72
3.29%
942.52
2.05%
16.38
3.17%
506.48
1.9%
Prediction on Cluster IBM (target machine)
59.52
2.03%
2971.10
1.6%
17.78
1.48%
1182.67
1.5%
17.53
0.77%
2411.35
6.4%
120.17
1.75%
6783.47
3.8%
82.28
7.62%
1043.01
3.5%
38.05
2.35%
1555.17
3.6%
19.48
2.11%
953.61
3.5%

App. Exec. T.
(AET)(Sec)
415.15
462.47
908.36
7596.21
1110.93
962.25
516.32
2922.24
1200.85
2265.40
6858.17
1079.13
1613.93
921.27

Table 3 shows the information generated by PAS2P toolkit to obtain and execute the signatures. Column 3
shows the trace log size obtained in the instrumentation module. Column 4 shows the table of phases size obtained
with pas2p tool, which contains the relevant phases of the application, column 5 shows the number of relevant
phases and column 6 shows the time required to analyze and obtain those relevant phases. It is important to remark
that, although the time required to analyze can be long, depending on the Log trace size, this process is only carried
out once in the base machine. Finally, the last two columns present the signature sizes without and with checkpoint
respectively. Clearly, there is a reduction of the signature size when constructed without checkpoints.
6. Conclusions and future work
This paper proposes the PAS2P toolkit in order to automate the PAS2P methodology due to its complexity,
providing users a way to make the whole process, from creating a signature to executing it on target systems, in

1833

Javier Panadero et al. / Procedia Computer Science 18 (2013) 1824 ‚Äì 1833
Table 3. Information generated by PAS2P toolkit by pasp2 tool
Application

Cores

CG-256
BT-256
SP-256
SMG2000-256
Sweep3D-256
Moldy-256
M.DynaMix-256

256
256
256
256
256
128
128

Log.

Trace
428
573
1200
912
4.5
2.7
1.9

MB
MB
MB
MB
GB
GB
GB

Table
of phases
5.8 KB
6.6 KB
72 KB
67.4 KB
67.3 KB
27 kB
14 KB

Relevant
Phases
4
13
13
7
5
4
2

Time required by
Pas2p tool (Sec)
297.03
222.27
441.31
398.64
1342.46
732.83
497.23

Signature W/O.
Checkpoint
7.8 KB
8.1 KB
14.2 KB
11.6 KB
4.1 KB
4.2 KB
5.2 KB

Signature W.
Checkpoint
3,6 GB
6,9 GB
16,5 GB
34 GB
520 GB
18.2 GB
732 MB

user-space in an easy and fully automatic way.
The executable Pas2p tool is a sequential tool that analyzes the trace log Ô¨Åle generated by our instrumentation.
However, depending on the trace log size, the tool requires more memory in order to process the data. For this
reason, we are working on the development of the parallel Pas2p tool. This code will allow us to use the same
number of processes that the application actually used to be executed, ensuring the reduction of the analysis time.
Nowadays, the signatures constructed in base machines can be executed in target machines only if they have
the same ISA (Instruction Set Architecture). We are developing a synthetic signature, which can be executed
independently to the machine architecture.
Acknowledgements
This research has been supported by the MICINN Spain under contract TIN2007-64974, the MINECO (MICINN)
Spain under contract TIN2011-24384, the European ITEA2 project H4H, No 09011 and the Avanza Competitividad I+D+I program under contract TSI-020400-2010-120.
References
[1] A. Wong, D. Rexachs, E. Luque, Extraction of parallel application signatures for performance prediction, High Performance Computing
and Communications, 10th IEEE International Conference (2010) 223‚Äì230.
[2] D. Bailey, E. Barszcz, J. Barton, D. Browning, The NAS Parallel Benchmarks, International Journal of Supercomputer Applications
5 (3) (1991) 66‚Äì73.
[3] A. Hoisie, O. Lubeck, H. Wasserman, Performance and scalability analysis of teraÔ¨Çop-scale parallel architectures using multidimensional, Journal of High Performance Computing Applications 14 (2000) 330‚Äì346.
[4] P. N. Brown, R. D. Falgout, J. E. Jones, Jim, E. Jones, Semicoarsening multigrid on distributed memory machines, SIAM Journal on
ScientiÔ¨Åc Computing 21 (2000) 1823‚Äì1834.
[5] K. Refson, Moldy: a portable molecular dynamics simulation program for serial and parallel computers, Computer Physics Communications 126 (3) (2000) 310 ‚Äì 329.
[6] A. P. Lyubartsev, A. Laaksonen, M.dynamix a scalable portable parallel md simulation package for arbitrary molecular mixtures,
Computer Physics Communications 128 (3) (2000) 565 ‚Äì 589.
[7] S. D. Hammond, G. R. Mudalige, J. A. Smith, S. A. Jarvis, J. A. Herdman, A. Vadgama, Warpp: a toolkit for simulating high-performance
parallel scientiÔ¨Åc codes, Proceedings of the 2nd International Conference on Simulation Tools and Techniques (2009) 1‚Äì10.
[8] R. Susukita, H. Ando, M. Aoyagi, H. Honda, Y. Inadomi, K. Inoue, S. Ishizuki, Y. Kimura, H. Komatsu, M. Kurokawa, K. J. Murakami,
H. Shibamura, S. Yamamura, Y. Yu, Performance prediction of large-scale parallell system and application using macro-level simulation,
Proceedings of the 2008 ACM/IEEE conference on Supercomputing (2008) 20:1‚Äì20:9.
[9] J. Zhai, W. Chen, W. Zheng, Phantom: predicting performance of parallel applications on large-scale parallel machines using a single
node (2010) 305‚Äì314.
[10] S. Prakash, R. L. Bagrodia, Mpi-sim: using parallel simulation to evaluate mpi programs, Proceedings of the 30th conference on Winter
simulation (1998) 467‚Äì474.
[11] S. Sharkawi, D. DeSota, R. Panda, S. Stevens, V. Taylor, X. Wu, Swapp: A framework for performance projections of hpc applications
using benchmarks, 2012 IEEE 26th International Parallel and Distributed Processing Symposium Workshops 0 (2012) 1722‚Äì1731.
[12] A. Snavely, L. Carrington, N. Wolter, J. Labarta, A framework for performance modeling and prediction, Supercomputing (2002) 1‚Äì17.
[13] S. Girona, J. Labarta, R. Badia, Validation of dimemas communication model for mpi collective operations, Proc. of the 7th European
PVM/MPI Users‚Äô Group Meeting on Recent Advances in Parallel Virtual Machine and Message Passing Interface (2000) 39‚Äì46.
[14] P. H. Hargrove, J. C. Duell, Berkeley lab checkpoint/restart (blcr) for linux clusters, Journal of Physics Conference Series 46 (1) (2006)
494‚Äì499.
[15] J. Ansel, K. Arya, G. Cooperman, Dmtcp: Transparent checkpointing for cluster computations and the desktop, Proceedings of the 2009
IEEE International Symposium on Parallel&Distributed Processing (2009) 1‚Äì12.

